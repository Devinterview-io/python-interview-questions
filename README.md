# Top 100 Python Interview Questions

<div>
<p align="center">
<a href="https://devinterview.io/questions/web-and-mobile-development/">
<img src="https://firebasestorage.googleapis.com/v0/b/dev-stack-app.appspot.com/o/github-blog-img%2Fweb-and-mobile-development-github-img.jpg?alt=media&token=1b5eeecc-c9fb-49f5-9e03-50cf2e309555" alt="web-and-mobile-development" width="100%">
</a>
</p>

#### You can also find all 100 answers here ðŸ‘‰ [Devinterview.io - Python](https://devinterview.io/questions/web-and-mobile-development/python-interview-questions)

<br>

## 1. What are the _key features_ of _Python_?

### Core Features of Python

Python is a high-level, interpreted programming language with several key features:

1. **Easy to Learn and Read**: Python's syntax emphasizes **readability** and uses indentation for scoping.
2. **Dynamically Typed**: No need to declare variable types explicitly; types are resolved at **runtime**.
3. **Object-Oriented**: Supports **classes and objects** while also enabling functional and procedural paradigms.
4. **Extensive Libraries**: Rich **Standard Library** and massive third-party ecosystems (PyPI) for AI/ML.
5. **Cross-Platform**: Runs on Windows, macOS, and Linux, now featuring enhanced **JIT compilation** performance.

#### Code Illustration
```python
# Dynamic typing with modern type hinting
version: str = "Python 3.13+"
version = 2026  # Re-assignment is valid at runtime

# Readability: Indentation defines the block
def display_feature(name):
    if name:
        print(f"Key Feature: {name}")

display_feature("Portability")
```

[BATCH-UPDATED: 2026-01-26]
<br>

## 2. How is _Python_ executed?

**Python** follows a multi-stage execution process that combines compilation and interpretation. While often called an "interpreted" language, it actually compiles source code into an intermediate format before execution.

### Compilation and the PVM

The execution flow consists of two primary stages:

1.  **Bytecode Compilation**: When a script is run, the Python compiler translates the high-level source code (`.py`) into **Bytecode**. Bytecode is a low-level, platform-independent representation of the code, often stored in `__pycache__` folders as `.pyc` files.
2.  **The Python Virtual Machine (PVM)**: The **PVM** is the runtime engine of Python. It iterates through the bytecode instructions and maps them to the corresponding machine-specific instructions.

This hybrid "compile-then-interpret" model allows Python to maintain **cross-platform compatibility** while optimizing the execution loop.

### The Execution Pipeline

The transition from source code to execution involves several discrete steps:

#### 1. Lexical Analysis
The **Lexer** breaks the source code into **tokens** (keywords, identifiers, operators, and literals), removing whitespace and comments.

#### 2. Parsing and AST Generation
The **Parser** organizes tokens into an **Abstract Syntax Tree (AST)**. The AST represents the logical structure of the program based on Python's grammar rules.

#### 3. Compilation to Bytecode
The compiler traverses the AST and generates **Bytecode**. This stage includes optimizations like **Constant Folding**, where simple expressions (e.g., $15 \times 20$) are pre-calculated.

#### 4. Interpretation and Execution
The **PVM** executes the bytecode. Modern versions of Python (3.11+) utilize a **Specializing Adaptive Interpreter**, which identifies "hot" code paths and optimizes them for faster execution during runtime.

### Just-In-Time (JIT) Compilation

In contemporary Python (specifically starting with versions like 3.13), a **JIT Compiler** has been introduced as an experimental feature. Unlike the standard interpreter that processes bytecode line-by-line, a **JIT** compiles frequently executed bytecode directly into **Machine Code** at runtime. 

By bypassing the PVM's interpretation overhead for performance-critical segments, JIT compilation significantly improves execution speed, bringing Python's performance closer to statically compiled languages.

### Code Example: Disassembling Bytecode

The `dis` module allows developers to inspect the bytecode generated by the compiler.

```python
import dis

def calculate_area():
    # The compiler performs constant folding: 15 * 20 = 300
    return 15 * 20

# Disassemble the function to view bytecode
dis.dis(calculate_area)
```

**Output (Python 3.11+):**
```plaintext
  1           0 RESUME                   0
  3           2 LOAD_CONST               1 (300)
              4 RETURN_VALUE
```

In this output, `LOAD_CONST` demonstrates that the multiplication was handled during the **Compilation** phase, while `RETURN_VALUE` is the instruction handled by the **PVM** at runtime.
<br>

## 3. What is _PEP 8_ and why is it important?

**PEP 8** is the primary style guide for **Python** code, prioritizing **readability**, **consistency**, and **maintainability**. It is a **Python Enhancement Proposal (PEP)**, the formal mechanism for proposing new features or processes to the Python community.

In 2026, while PEP 8 remains the foundational standard, it is increasingly enforced by high-performance automated tools like **Ruff** and **Black**, which ensure codebases adhere to these conventions with minimal manual effort.

### Key Design Principles

PEP 8 is governed by the philosophy that "code is read much more often than it is written":

- **Readability**: Code should be transparent and easy to understand for any developer, not just the author.
- **Consistency**: A uniform style across a project reduces cognitive load and simplifies code reviews.
- **The Zen of Python**: It advocates for "oneâ€”and preferably only oneâ€”obvious way to do it," discouraging fragmented coding styles.

### Base Rules

- **Indentation**: Use **4 spaces** per indentation level. Avoid using tabs.
- **Line Length**: Limit code lines to **79 characters**. For long blocks of text (docstrings or comments), a limit of **72 characters** is recommended.
- **Blank Lines**: Surround top-level function and class definitions with two blank lines. Method definitions inside a class are surrounded by a single blank line.

### Naming Styles

- **Class Names**: Use **CapWords** (also known as `CamelCase` or `PascalCase`).
- **Function and Variable Names**: Use `lowercase_with_underscores` (snake_case).
- **Constants**: Use `UPPER_CASE_WITH_UNDERSCORES` to denote values that do not change.
- **Module Names**: Keep them short and in `lowercase`.

### Documentation

- **Docstrings**: Use **triple double quotes** (`"""`) for all public modules, functions, classes, and methods.
- **Comments**: Should be complete sentences. Inline comments should be separated by at least two spaces from the statement they describe.

### Whitespace Usage

- **Operators**: Surround binary operators (assignment, comparisons, Booleans) with a single space (e.g., $x = y + 1$).
- **Punctuation**: Avoid extraneous whitespace immediately inside parentheses, brackets, or braces, and immediately before a comma.

### Example: Directory Walker

The following code demonstrates a **PEP 8** compliant structure:

```python
import os
from typing import List

def walk_directory(path: str) -> List[str]:
    """Iterate through a directory and return a list of file paths."""
    file_list = []
    for dirpath, dirnames, filenames in os.walk(path):
        for filename in filenames:
            file_path = os.path.join(dirpath, filename)
            file_list.append(file_path)
    return file_list

if __name__ == "__main__":
    # Example execution
    files = walk_directory('/path/to/directory')
    for f in files:
        print(f)
```
<br>

## 4. How is memory allocation and garbage collection handled in _Python_?

In Python, **memory allocation** and **garbage collection** are handled automatically by the interpreter, abstracting complex memory management away from the developer.

### Memory Allocation

Python manages a **private heap** that contains all Python objects and data structures. The **Python Memory Manager** ensures that the heap is efficiently utilized through several layers of abstraction.

- **PyMalloc (obmalloc):** For small objects (typically $\leq 512$ bytes), Python uses a specialized allocator. It organizes memory into **Arenas** (256 KB), which are carved into **Pools** (4 KB), and then into **Blocks**. This minimizes the overhead of frequent system-level `malloc` calls.
- **Raw Allocator:** For large objects, Python bypasses its internal pool system and requests memory directly from the operating systemâ€™s heap using standard C library functions (e.g., `malloc`).
- **Object-Specific Allocators:** Python also employs specific allocators for frequently used types like integers and strings to further enhance performance and reduce fragmentation.

```python
import sys

# Small object (handled by PyMalloc)
x = 100
print(f"Size of x: {sys.getsizeof(x)} bytes")

# Large object (handled by Raw Allocator)
y = "A" * 10**6
print(f"Size of y: {sys.getsizeof(y)} bytes")
```

### Garbage Collection

Python uses a dual approach to garbage collection: **Reference Counting** and a **Generational Garbage Collector**.

#### Reference Counting

- Every object has an internal `ob_refcnt` field. When an object is referenced, this count increases; when a reference is deleted or goes out of scope, the count decreases.
- If the count reaches zero, the object is immediately deallocated. This is the primary and most efficient way Python reclaims memory.

#### Generational Garbage Collector

- Reference counting cannot handle **circular references** (e.g., two objects pointing to each other). To solve this, Python's `gc` module periodically scans for cycles.
- It uses a **generational approach** with three generations ($G_0$, $G_1$, and $G_2$). New objects start in $G_0$. If they survive a collection, they move to an older generation.
- Older generations are scanned less frequently than younger ones, based on the heuristic that most objects have short lifespans.

```python
import gc

# Check current thresholds for G0, G1, G2
print(f"GC Thresholds: {gc.get_threshold()}")

# Manually trigger a collection
gc.collect()
```

### Memory Management in Python vs. C

Python's memory management model offers significant trade-offs compared to manual management in C:

- **Safety and Convenience:** Python prevents **memory leaks**, **buffer overflows**, and **use-after-free** errors, which are common in C/C++.
- **Memory Overhead:** Every Python object carries metadata (type and reference count), making Python more memory-intensive. For example, a 28-byte integer in Python requires significantly more space than a 4-byte `int` in C.
- **Deterministic vs. Non-deterministic:** While reference counting is deterministic (immediate), the generational GC is non-deterministic, potentially causing small, unpredictable pauses during execution.
- **Modern Optimizations:** Recent Python versions (3.11+) have integrated improvements like **mimalloc** and refined GC algorithms to close the performance gap with lower-level languages.
<br>

## 5. What are the _built-in data types_ in _Python_?

Python offers a robust set of **built-in data types** categorized primarily by their **mutability**. Understanding these is essential for memory management and performance optimization.

### Immutable Data Types

#### 1. int
Represents arbitrary-precision integers. Unlike many languages, Python's `int` can handle safely sized numbers limited only by available memory.

#### 2. float
Represents double-precision floating-point numbers (standard IEEE 754). For higher precision, the `decimal` module is preferred.

#### 3. complex
Used for mathematical computations involving a real and an imaginary part, represented as $a + bj$.

#### 4. bool
A subclass of `int` representing truth values: `True` (1) and `False` (0).

#### 5. str
An immutable sequence of **Unicode characters**. Strings support extensive slicing and formatting methods.

#### 6. tuple
An ordered, immutable collection. Tuples are often used to store heterogeneous data and can be used as keys in dictionaries if they contain only hashable elements.

#### 7. frozenset
A hashable, immutable version of a `set`. It is defined using the `frozenset()` constructor and is useful for set operations where the collection must remain constant.

#### 8. bytes
An immutable sequence of single bytes ($0 \le x < 256$), typically used for handling binary data and encoded text.

#### 9. range
Represents an immutable sequence of numbers, commonly used for looping a specific number of times in `for` loops without storing the entire sequence in memory.

#### 10. NoneType
The type for the `None` singleton, used to signify the absence of a value or a default return value for functions.

### Mutable Data Types

#### 1. list
A dynamic, ordered array that can contain heterogeneous elements. It is optimized for fast fixed-index access and end-of-list operations.

#### 2. set
An unordered collection of unique, hashable objects. It provides $O(1)$ average-time complexity for membership testing.

#### 3. dict
A collection of key-value pairs. Since Python 3.7+, `dict` maintains **insertion order** as a language feature.

#### 4. bytearray
A mutable counterpart to the `bytes` type. It allows in-place modification of binary data.

#### 5. memoryview
A generalized interface for accessing the internal data of an object that supports the **buffer protocol** (like `bytes` or `bytearray`) without copying it.

#### 6. array (array.array)
Part of the `array` module, this provides space-efficient storage of basic values (integers, floats) constrained to a single C-style data type.

#### 7. deque (collections.deque)
A double-ended queue optimized for $O(1)$ additions and removals from both the beginning and the end.

#### 8. object
The most fundamental base class in Python. All other types, including classes and functions, inherit from `object`.

#### 9. types.SimpleNamespace
A simple object subclass that provides attribute access to its namespace, essentially a `dict` with dot-notation access.

#### 10. types.FunctionType
The internal type for user-defined functions, allowing for the inspection and dynamic creation of function objects.

```python
# Examples of modern type usage and literals
integer_val = 1_000_000             # int with underscores for readability
binary_data = b"Hello"              # bytes
mutable_bytes = bytearray(b"Hi")    # bytearray
unique_items = {1, 2, 3}            # set
mapping = {"key": "value"}          # dict (ordered by insertion)

# Efficient data manipulation
view = memoryview(mutable_bytes)
view[0] = 72  # Modifies mutable_bytes to b"Hi" -> b"Hi" is now b"Hi"
```
<br>

## 6. Explain the difference between a _mutable_ and _immutable_ object.

In Python, every object has an **identity**, a **type**, and a **value**. The distinction between mutable and immutable objects is fundamental to how Python manages memory and handles data assignments.

### Key Distinctions

- **Mutable Objects**: Their state or contents can be changed in-place after creation without changing the object's unique **identity** (`id()`).
- **Immutable Objects**: Their state cannot be modified once created. Any operation that appears to modify an immutable object actually creates a **new object** in memory with a new identity.

### Common Examples

- **Mutable**: `list`, `dict`, `set`, `bytearray`.
- **Immutable**: `int`, `float`, `complex`, `str`, `tuple`, `bool`, `frozenset`, `bytes`.

### Code Example: Immutability in Python

```python
# Immutable objects: (int, str, tuple)
text = "Python"
my_tuple = (1, 2, 3)

# Modifying contents directly raises a TypeError
try:
    text[0] = 'p'        # Raises TypeError
    my_tuple[0] = 100    # Raises TypeError
except TypeError as e:
    print(f"Error: {e}")

# Re-assignment creates a new object (Name Rebinding)
x = 10
initial_id = id(x)
x += 1 
print(id(x) == initial_id)  # Output: False (New memory address)

# Mutable objects: (list, dict)
my_list = [1, 2, 3]
list_id = id(my_list)
my_list.append(4)           # Modified in-place
print(id(my_list) == list_id) # Output: True (Same memory address)
```

### Benefits & Trade-Offs

#### Immutability
- **Thread-Safety**: Immutable objects are inherently thread-safe because their state cannot change, preventing race conditions.
- **Hashability**: Only immutable objects (or tuples containing only immutable objects) are **hashable**. This allows them to serve as **dictionary keys** or elements in a **set**.
- **Predictability**: Functions cannot inadvertently modify immutable arguments, reducing side effects.

#### Mutability
- **Performance**: In-place updates are more efficient for large datasets. Appending to a list is generally $O(1)$, whereas "appending" to a string or tuple requires a full copy, which is $O(n)$.
- **Memory Efficiency**: Mutability avoids the overhead of creating redundant temporary objects during frequent updates.

### Impact on Operations

- **Reading and Writing**: Immutable objects favor **read-heavy** workloads and functional programming patterns. Mutability is preferred for **write-heavy** data structures.
- **Hash Functions**: Python requires that a key's hash remains constant throughout its lifetime. This is expressed as: 
$$hash(object) = \text{constant}$$
If an object were mutable and its value changed, its hash would change, breaking the lookup mechanism in hash tables (dictionaries).

Choosing between the two depends on the need for data integrity versus the requirement for high-performance, in-place data manipulation.
<br>

## 7. How do you _handle exceptions_ in _Python_?

**Exception handling** in Python is a robust mechanism used to manage runtime errors, ensuring the program's flow is not interrupted unexpectedly. As of 2026, the core syntax remains stable, with enhanced support for concurrent error handling.

### Core Components

- **`try`**: Encapsulates code that might throw an exception.
- **`except`**: Catches and handles specific exceptions. Multiple `except` blocks can follow a single `try`.
- **`else`**: Executes only if the code in the `try` block did **not** raise an exception.
- **`finally`**: Executes regardless of whether an exception occurred. It is essential for **resource cleanup**, such as closing file streams or network sockets.

### Handling Specific vs. General Exceptions

It is a best practice to catch specific exceptions to avoid masking unrelated bugs. Specific handlers should always precede general ones.

```python
try:
    process_data()
except FileNotFoundError:  # Specific exception
    handle_missing_file()
except Exception as e:      # General catch-all
    log_error(e)
finally:
    release_resources()
```

### Raising and Chaining Exceptions

The `raise` keyword triggers an exception manually. In modern Python, **exception chaining** using `from` is preferred when re-raising to preserve the original traceback (the "cause").

```python
def get_config(path):
    try:
        with open(path, 'r') as f:
            return f.read()
    except OSError as e:
        # Chaining allows debugging the original 'e' while raising a custom error
        raise RuntimeError("Configuration load failed") from e
```

### Modern Handling: Exception Groups

Introduced in Python 3.11 and standard by 2026, `ExceptionGroup` and the `except*` syntax allow handling multiple exceptions simultaneously, which is common in **asynchronous programming** and `TaskGroups`.

```python
try:
    async with asyncio.TaskGroup() as tg:
        tg.create_task(task_one())
        tg.create_task(task_two())
except* (ValueError, TypeError) as eg:
    for e in eg.exceptions:
        print(f"Caught part of group: {e}")
```

### Resource Management with `with`

The `with` statement utilizes **Context Managers** (`__enter__` and `__exit__`) to handle setup and teardown automatically. This is the most "Pythonic" way to prevent resource leaks.

```python
with open("data.json", "w") as file:
    file.write(json_string)
# File is closed automatically even if an exception occurs during write.
```

### Control Flow: `pass`, `continue`, and `else`

- **`pass`**: Used within an `except` block to suppress an error silently.
- **`continue`**: Used within a loop's `except` block to skip the current iteration and move to the next.
- **`else`**: Useful for logic that should only run if the `try` block succeeded, separating the "happy path" from the error handling.

### Global Exception Hook: `sys.excepthook`

For top-level error logging or custom crash reporting, you can override the global exception handler. This captures any exception that is not caught by a `try-except` block.

```python
import sys

def custom_hook(type, value, traceback):
    print(f"Uncaught global exception: {value}")
    # Optional: sys.__excepthook__(type, value, traceback)

sys.excepthook = custom_hook
```

*Note: `sys.excepthook` does not trigger for `SystemExit` or exceptions raised in the interactive REPL.*
<br>

## 8. What is the difference between _list_ and _tuple_?

**Lists** and **Tuples** in Python are sequence types that support indexing and slicing, yet they differ in several fundamental ways:

### Key Distinctions

- **Mutability**: Lists are **mutable**, allowing you to add, remove, or modify elements in place. Tuples are **immutable**; once defined, their elements and length cannot be changed.
- **Memory & Performance**: Tuples are more **memory-efficient** and faster to instantiate. Lists require extra memory overhead (over-allocation) to support dynamic resizing during `append` operations.
- **Hashability**: Because they are immutable, tuples are **hashable** (provided their elements are also hashable). This allows them to be used as **dictionary keys** or stored in **sets**, whereas lists cannot.
- **Syntax**: Lists are defined with square brackets `[]`, whereas tuples use parentheses `()`.

### When to Use Each

- **Lists** are ideal for collections of **homogeneous** data that may change in size or content during the program's lifecycle.
- **Tuples** are the preferred choice for **heterogeneous** data structures or fixed records, such as a coordinate pair $(x, y)$ or a database row.

### Syntax Examples

#### List: Mutable Sequence

```python
my_list = ["apple", "banana", "cherry"]
my_list.append("date")
my_list[1] = "blackberry"
```

#### Tuple: Immutable Sequence

```python
my_tuple = (1, 2, 3, 4)
# Unpacking a tuple
a, b, c, d = my_tuple
# my_tuple[0] = 10  # This would raise a TypeError
```
<br>

## 9. How do you create a _dictionary_ in _Python_?

**Python dictionaries** are versatile data structures that map unique keys to values, providing $O(1)$ average time complexity for lookups. In modern Python (3.7+), dictionaries also maintain **insertion order**.

### Key Concepts

- A **dictionary** consists of a collection of `key:value` pairs.
- **Keys** must be **hashable** (immutable), such as strings, numbers, or tuples.
- **Values** can be of any data type, including lists or other dictionaries, and can be duplicated.
- Dictionaries are mutable, allowing for dynamic updates to their content.

### Creating a Dictionary

You can use several methods to create a dictionary depending on the data source:

1. **Literal Definition**: Defining key-value pairs within curly braces `{}`.
2. **`dict()` Constructor**: Converting sequences of key-value pairs or using named arguments.
3. **Dictionary Comprehensions**: A concise, programmatic way to generate dictionaries.
4. **`zip()` Function**: Mapping two separate sequences (keys and values) into a single dictionary.
5. **`dict.fromkeys()`**: Creating a dictionary with a predefined set of keys and a single default value.

### Examples

#### Dictionary Literal Definition

This is the most common and readable way to initialize a dictionary.

```python
# Dictionary literal definition
student = {
    "name": "John Doe",
    "age": 21,
    "courses": ["Math", "Physics"]
}
```

#### Using the `dict()` Constructor

The `dict()` constructor is flexible, accepting iterables of pairs or keyword arguments.

```python
# From a sequence of tuples
student_dict = dict([
    ("name", "John Doe"),
    ("age", 21)
])

# Using keyword arguments (keys must be valid identifiers)
student_dict_short = dict(name="John Doe", age=21, courses=["Math", "Physics"])
```

#### Using `zip()` and `fromkeys()`

`zip()` is ideal for merging two lists, while `fromkeys()` initializes dictionaries with default values.

```python
keys = ["a", "b", "c"]
values = [1, 2, 3]

# Mapping two lists together
dict_from_zip = dict(zip(keys, values)) # {"a": 1, "b": 2, "c": 3}

# Initializing with a default value
default_dict = dict.fromkeys(keys, 0) # {"a": 0, "b": 0, "c": 0}
```

#### Comprehensions and Merging

Comprehensions allow for logic during creation, while the **union operator** (`|`) is the modern (Python 3.9+) way to merge dictionaries.

```python
# Dictionary comprehension
squares = {x: x**2 for x in range(5)}

# Merging dictionaries using the union operator
dict_a = {"x": 1, "y": 2}
dict_b = {"z": 3}
combined = dict_a | dict_b # {"x": 1, "y": 2, "z": 3}
```
<br>

## 10. What is the difference between _==_ and _is operator_ in _Python_?

### Equality vs. Identity in Python

Both the **`==`** and **`is`** operators are used for comparison, but they evaluate fundamentally different properties of objects.

*   The **`==`** operator checks for **Value Equality**. It determines if the data stored within the objects is the same by invoking the `__eq__` method.
*   The **`is`** operator validates **Object Identity**. It determines if two variables point to the exact same memory location.

In Python, every object is identifiable by a unique memory address. The **`is`** operator compares these addresses ($id(a) == id(b)$). Even if two objects look identical, they are distinct if they reside in different memory slots.

```python
list_a = [1, 2, 3]
list_b = [1, 2, 3]
list_c = list_a

print(list_a == list_b) # True: The values are the same
print(list_a is list_b) # False: They are different objects in memory
print(list_a is list_c) # True: Both reference the same object
```

#### Best Practices for 2026

*   **`==`**: Use this for almost all equality comparisons, such as comparing strings, numbers, or data structures.
*   **`is`**: Use this specifically when comparing against **Singletons**. The most common use case is checking for **`None`** (e.g., `if val is None:`). 

#### Implementation Note
Avoid using **`is`** with literals (like integers or strings). While Python performs **interning** (reusing memory for small integers and certain strings), this is an implementation detail. Using **`is`** for value comparison with literals is technically incorrect and often triggers a **SyntaxWarning** in modern Python versions.
<br>

## 11. How does a _Python function_ work?

A **Python function** is a first-class object that encapsulates a reusable block of code. In Python, functions are defined using the `def` keyword and represent a mapping between inputs (arguments) and outputs (return values).

### Key Components

- **Function Signature**: Defined by the `def` keyword, it includes the function name, **parameters** (with optional **type hints**), and a return type annotation.
- **Function Body**: An indented block containing the logic. In modern Python, this is compiled into **bytecode** before execution.
- **Return Statement**: Specifies the result. If no `return` is explicitly defined, the function implicitly returns `None`.
- **Function Object**: In Python, functions are **first-class citizens**, meaning they can be assigned to variables, passed as arguments, and returned from other functions.

### Execution Process

When a **Python function** is invoked:

1. **Stack Frame Creation**: The Python Interpreter creates a new **frame object** on the **call stack**. This frame stores local variables, the **instruction pointer**, and references to the global and built-in namespaces.
  
2. **Argument Binding**: Arguments are bound to the parameters defined in the signature. Python uses **pass-by-object-reference**; the local name in the function refers to the same object in memory as the callerâ€™s argument.

3. **Bytecode Execution**: The interpreter executes the functionâ€™s **bytecode** sequentially. If the function is a generator (uses `yield`), execution can be suspended and resumed.

4. **Return and Cleanup**: When a `return` is reached, the result is pushed to the caller's stack. The function's **stack frame** is popped, and the local variables' reference counts are decremented, potentially triggering **Garbage Collection**.

```python
def calculate_power(base: int, exponent: int = 2) -> int:
    """Calculates base raised to the exponent."""
    result = base ** exponent  # 'result' is a local variable
    return result

# Function call
output = calculate_power(5, 3) 
```

### Variable Scope and Resolution

Python follows the **LEGB Rule** for variable resolution:

- **Local (L)**: Names assigned within the function (and not declared global).
- **Enclosing (E)**: Names in the local scope of any enclosing functions (relevant for **closures**).
- **Global (G)**: Names assigned at the top level of the module or declared `global`.
- **Built-in (B)**: Names pre-assigned in the built-in names module (e.g., `len`, `range`).

#### Modifying Non-Local Variables
To modify a variable outside the local scope, the `global` or `nonlocal` keywords must be used. Without them, assigning to a variable of the same name creates a new local variable, shielding the outer one.

### Memory Management and Optimization

Functions in Python 3.11+ benefit from the **Specializing Adaptive Interpreter**, which optimizes function calls by identifying "hot" code paths. 
- **Local Variable Access**: Accessing local variables is faster than global variables because locals are stored in a fixed-size array within the **stack frame**, whereas globals require a dictionary lookup.
- **Recursion Limit**: Python imposes a maximum recursion depth to prevent stack overflows, which can be checked via `sys.getrecursionlimit()`.

#### Mathematical Representation of Execution
The complexity of a simple function call in terms of time is generally $O(1)$ for the overhead, though the internal logic determines the overall complexity $O(f(n))$.
<br>

## 12. What is a _lambda function_, and where would you use it?

A **Lambda function** is a small, anonymous function defined using the `lambda` keyword. In Python, its syntax follows the structure `lambda arguments: expression`. Unlike standard functions defined with `def`, lambdas are restricted to a single expression and are often used for short-lived operations where a formal function name would be unnecessary.

### Distinctive Features

- **Anonymity**: Lambdas are not bound to a name by default, making them suitable for one-off tasks.
- **Single Expression Body**: Their body is limited to a single logical expression. It cannot contain statements (e.g., `pass`, `assert`, or assignments) or multiple lines.
- **Implicit Return**: The evaluated result of the expression is returned automatically; the `return` keyword is not used.
- **Conciseness**: They reduce boilerplate code by allowing inline function definitions.

### Common Use Cases

- **Functional Programming Tools**: Lambdas are frequently passed as arguments to higher-order functions like `map()`, `filter()`, and `reduce()`.
    ```python
    # Doubling elements in a list: f(x) = x \cdot 2
    numbers = [1, 2, 3, 4]
    doubled = list(map(lambda x: x * 2, numbers))
    ```
- **Custom Sorting and Min/Max**: They serve as the `key` argument for sorting complex data structures.
    ```python
    # Sorting a list of dictionaries by a specific key
    data = [{'name': 'Alpha', 'id': 3}, {'name': 'Beta', 'id': 1}]
    sorted_data = sorted(data, key=lambda x: x['id'])
    ```
- **Callbacks**: In event-driven programming or GUI frameworks (like Tkinter or PyQt), lambdas provide a quick way to define small callback actions.
- **Closures**: They can be used to generate specific functions within a wrapper.
    ```python
    def multiplier(n):
        return lambda x: x * n
    ```

### Notable Limitations

- **Readability**: Overusing lambdas or using them for complex logic violates the "Zen of Python" principle that "readability counts." 
- **Debugging Hurdles**: Because they are anonymous, tracebacks identify them only as `<lambda>`, which can make pinpointing errors more difficult than with named functions.
- **No Documentation**: Lambdas do not support docstrings, making it impossible to provide built-in documentation for the logic they perform.
- **Alternative Preference**: In modern Python (up to 2026), **List Comprehensions** and **Generator Expressions** are often preferred over `map` and `filter` with lambdas for better performance and clarity. 
    - *Example*: `[x * 2 for x in numbers]` is generally preferred over `map(lambda x: x * 2, numbers)`.
<br>

## 13. Explain _*args_ and _**kwargs_ in _Python_.

In Python, `*args` and `**kwargs` allow a function to accept a variable number of arguments, providing flexibility in function definitions.

`*args` collects positional arguments into a **tuple**, while `**kwargs` collects keyword arguments into a **dictionary**.

### **\*args**: Variable Positional Arguments

- **Mechanism**: The asterisk (`*`) operator packs any remaining positional arguments into a **tuple**. While `args` is the naming convention, any identifier can be used.
- **Use-Case**: When the number of input values is not predefined, such as in mathematical aggregations or list processing.

#### Code Example: `*args`

```python
def sum_all(*args):
    # args is treated as a tuple: (1, 2, 3, 4)
    return sum(args)

print(sum_all(1, 2, 3, 4))  # Output: 10
```

### **\*\*kwargs**: Variable Keyword Arguments

- **Mechanism**: The double asterisk (`**`) operator captures named arguments into a **dictionary**, where the parameter names are keys and their values are the dictionary values.
- **Use-Case**: For functions requiring flexible configuration, handling optional parameters, or forwarding arguments to other functions (decorators).

#### Code Example: `**kwargs`

```python
def print_profile(**kwargs):
    # kwargs is treated as a dictionary
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_profile(name="John", age=30, city="New York")
# Output:
# name: John
# age: 30
# city: New York
```

### **Argument Order and Unpacking**

In Python, there is a strict order for function parameters to avoid ambiguity:
1. Formal positional arguments.
2. `*args`.
3. Keyword-only arguments.
4. `**kwargs`.

Additionally, the `*` and `**` operators can be used for **unpacking** sequences and dictionaries into function calls:

```python
numbers = [1, 2, 3]
config = {"color": "red", "size": "large"}

# Unpacking into function call
some_function(*numbers, **config)
```

This syntax ensures that functions remain extensible and maintainable, especially when the specific requirements of the caller may change over time.
<br>

## 14. What are _decorators_ in _Python_?

In Python, a **decorator** is a design pattern and a language feature that allows you to modify or extend the behavior of functions, methods, or classes dynamically. This is primarily used to keep code clean, maintainable, and **DRY** (Don't Repeat Yourself) by separating cross-cutting concerns from core logic.

### How Decorators Work

- **Wrappers**: Decorators wrap a target function, allowing you to execute custom code before and after the target executes.
- **Higher-Order Functions**: They are functions that take another function as an argument and return a new function.
- **Metaprogramming**: This paradigm of "code that manipulates code" allows for powerful abstractions at runtime.

### Common Use Cases

- **Authorization and Authentication**: Validating user permissions before executing logic.
- **Logging**: Recording function calls, arguments, and execution states.
- **Caching/Memoization**: Storing expensive function results (e.g., `functools.lru_cache`).
- **Validation**: Enforcing constraints on input parameters or return values.
- **Profiling**: Measuring execution time: $T_{total} = T_{end} - T_{start}$.
- **Framework Routing**: Mapping functions to web routes in libraries like FastAPI or Flask.

### Using Decorators in Code

In modern Python (2026), decorators frequently utilize **Type Hinting** for better static analysis and IDE support.

```python
from functools import wraps
from typing import Callable, Any

# 1. Basic Decorator
def my_decorator(func: Callable) -> Callable:
    @wraps(func)  # Preserves original function metadata
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        print('Executing logic before the function.')
        result = func(*args, **kwargs)
        print('Executing logic after the function.')
        return result
    return wrapper

@my_decorator
def say_hello(name: str) -> None:
    print(f'Hello, {name}!')

# 2. Decorators with Arguments (Decorator Factory)
def repeat(times: int) -> Callable:
    def actual_decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            result = None
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return actual_decorator

@repeat(times=3)
def greet() -> None:
    print('Greetings!')
```

### Decorator Syntax and Metadata

The `@decorator` syntax is **syntactic sugar** for passing the function into the decorator and reassigning the identifier:

```python
def say_hello():
    print('Hello!')
say_hello = my_decorator(say_hello)
```

#### Role of functools.wraps

When a function is decorated, its identity technically changes to the internal `wrapper`. Using `@wraps(func)` is a best practice that copies the original functionâ€™s **metadata** (such as `__name__`, `__doc__`, and type annotations) to the wrapper. This ensures that introspection tools and debuggers correctly identify the original function.
<br>

## 15. How can you create a _module_ in _Python_?

A **module** in Python is a file containing Python definitions and statements. It allows you to logically organize your code and promotes reusability across different projects.

### Methods of Creation

You can **create** a Python module through the following standard methods:

- **Define a .py File**: Save a Python file with a `.py` extension. This file automatically functions as a module, where the filename is the module's name.
- **Initialize a Package**: To group multiple modules, create a directory containing an `__init__.py` file. This tells Python to treat the directory as a **package**.

Next, use the **import** statement to access the module and its functionality within other scripts.

### Code Example: Creating a `math_operations` Module

#### Module Definition

Save the following code as `math_operations.py`:

```python
def add(x, y):
    return x + y

def subtract(x, y):
    return x - y

def multiply(x, y):
    return x * y

def divide(x, y):
    return x / y if y != 0 else "Error: Division by zero"
```

#### Module Usage

You can utilize the `math_operations` module by using **import** as shown below:

```python
import math_operations

result = math_operations.add(4, 5)
print(result)

result = math_operations.divide(10, 5)
print(result)
```

You can also use the statement `from math_operations import *` to import all members (functions and classes) at once, though this is generally discouraged to avoid **namespace pollution**:

```python
from math_operations import add, subtract

result = add(3, 2)
print(result)
```

### Best Practice
To ensure high-quality and maintainable code, follow these **Best Practices**:

- **Avoid Global Variables**: Encapsulate logic within functions or classes.
- **Guard Against Code Execution**: To prevent code from running automatically when the module is imported, use the following block:

```python
def main():
    # Primary logic or tests go here
    print("Module executed directly")

if __name__ == "__main__":
    main()
```

This ensures that the block following `if __name__ == "__main__":` is only executed when the file is run as a **standalone script**, and not when it is imported as a dependency in another module.
<br>



#### Explore all 100 answers here ðŸ‘‰ [Devinterview.io - Python](https://devinterview.io/questions/web-and-mobile-development/python-interview-questions)

<br>

<a href="https://devinterview.io/questions/web-and-mobile-development/">
<img src="https://firebasestorage.googleapis.com/v0/b/dev-stack-app.appspot.com/o/github-blog-img%2Fweb-and-mobile-development-github-img.jpg?alt=media&token=1b5eeecc-c9fb-49f5-9e03-50cf2e309555" alt="web-and-mobile-development" width="100%">
</a>
</p>

